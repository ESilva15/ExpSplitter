// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: expenses.sql

package repository

import (
	"context"
	"database/sql"
)

const deleteExpense = `-- name: DeleteExpense :execresult
DELETE FROM expenses WHERE "ExpID" = ?
`

func (q *Queries) DeleteExpense(ctx context.Context, expid int64) (sql.Result, error) {
	return q.db.ExecContext(ctx, deleteExpense, expid)
}

const getExpense = `-- name: GetExpense :one
SELECT 
  expenses.ExpID, expenses.Description, expenses.Value, expenses.StoreID, expenses.CategoryID, expenses.OwnerUserID, expenses.TypeID, expenses.ExpDate, expenses.CreationDate, expenses.PaidOff, expenses.SharesEven,
  stores.StoreID, stores.StoreName,
  categories.CategoryID, categories.CategoryName,
  users.UserID, users.UserName, users.UserPass,
  types.TypeID, types.TypeName
FROM expenses
JOIN 
  Stores ON stores.StoreID = expenses.StoreID
JOIN 
  Categories ON categories.CategoryID = expenses.CategoryID
JOIN 
  Users ON "UserID" = "OwnerUserId"
JOIN
  "expenseTypes" as types ON types.TypeID = expenses.TypeID
WHERE 
  "ExpID" = ?
`

type GetExpenseRow struct {
	Expense     Expense
	Store       Store
	Category    Category
	User        User
	ExpenseType ExpenseType
}

func (q *Queries) GetExpense(ctx context.Context, expid int64) (GetExpenseRow, error) {
	row := q.db.QueryRowContext(ctx, getExpense, expid)
	var i GetExpenseRow
	err := row.Scan(
		&i.Expense.ExpID,
		&i.Expense.Description,
		&i.Expense.Value,
		&i.Expense.StoreID,
		&i.Expense.CategoryID,
		&i.Expense.OwnerUserID,
		&i.Expense.TypeID,
		&i.Expense.ExpDate,
		&i.Expense.CreationDate,
		&i.Expense.PaidOff,
		&i.Expense.SharesEven,
		&i.Store.StoreID,
		&i.Store.StoreName,
		&i.Category.CategoryID,
		&i.Category.CategoryName,
		&i.User.UserID,
		&i.User.UserName,
		&i.User.UserPass,
		&i.ExpenseType.TypeID,
		&i.ExpenseType.TypeName,
	)
	return i, err
}

const getExpenses = `-- name: GetExpenses :many
SELECT 
  expenses.ExpID, expenses.Description, expenses.Value, expenses.StoreID, expenses.CategoryID, expenses.OwnerUserID, expenses.TypeID, expenses.ExpDate, expenses.CreationDate, expenses.PaidOff, expenses.SharesEven,
  stores.StoreID, stores.StoreName,
  categories.CategoryID, categories.CategoryName,
  users.UserID, users.UserName, users.UserPass,
  types.TypeID, types.TypeName
FROM expenses
JOIN 
  Stores ON stores.StoreID = expenses.StoreID
JOIN 
  Categories ON categories.CategoryID = expenses.CategoryID
JOIN 
  Users ON UserID = OwnerUserId
JOIN
  "expenseTypes" as types ON types.TypeID = expenses.TypeID
WHERE
  (?1 IS NULL OR expenses."ExpDate" >= ?1)
  AND
  (?2 IS NULL OR expenses."ExpDate" <= ?2)
`

type GetExpensesParams struct {
	Startdate interface{}
	Enddate   interface{}
}

type GetExpensesRow struct {
	Expense     Expense
	Store       Store
	Category    Category
	User        User
	ExpenseType ExpenseType
}

func (q *Queries) GetExpenses(ctx context.Context, arg GetExpensesParams) ([]GetExpensesRow, error) {
	rows, err := q.db.QueryContext(ctx, getExpenses, arg.Startdate, arg.Enddate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetExpensesRow
	for rows.Next() {
		var i GetExpensesRow
		if err := rows.Scan(
			&i.Expense.ExpID,
			&i.Expense.Description,
			&i.Expense.Value,
			&i.Expense.StoreID,
			&i.Expense.CategoryID,
			&i.Expense.OwnerUserID,
			&i.Expense.TypeID,
			&i.Expense.ExpDate,
			&i.Expense.CreationDate,
			&i.Expense.PaidOff,
			&i.Expense.SharesEven,
			&i.Store.StoreID,
			&i.Store.StoreName,
			&i.Category.CategoryID,
			&i.Category.CategoryName,
			&i.User.UserID,
			&i.User.UserName,
			&i.User.UserPass,
			&i.ExpenseType.TypeID,
			&i.ExpenseType.TypeName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertExpense = `-- name: InsertExpense :execresult
INSERT INTO expenses(
  "Description",
  "Value",
  "StoreID",
  "CategoryID",
  "TypeID",
  "OwnerUserID",
  "ExpDate",
  "PaidOff",
  "SharesEven",
  "CreationDate"
)
VALUES(?, ?, ? , ?, ?, ?, ?, ?, ?, ?)
`

type InsertExpenseParams struct {
	Description  string
	Value        string
	StoreID      int64
	CategoryID   int64
	TypeID       int64
	OwnerUserID  int64
	ExpDate      int64
	PaidOff      bool
	SharesEven   bool
	CreationDate int64
}

func (q *Queries) InsertExpense(ctx context.Context, arg InsertExpenseParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, insertExpense,
		arg.Description,
		arg.Value,
		arg.StoreID,
		arg.CategoryID,
		arg.TypeID,
		arg.OwnerUserID,
		arg.ExpDate,
		arg.PaidOff,
		arg.SharesEven,
		arg.CreationDate,
	)
}

const updateExpense = `-- name: UpdateExpense :execresult
UPDATE expenses
SET
  "Description" = ?,
  "Value" = ?,
  "StoreID" = ?,
  "CategoryID" = ?,
  "TypeID" = ?,
  "OwnerUserID" = ?,
  "PaidOff" = ?,
  "SharesEven" = ?,
  "ExpDate" = ?
WHERE "ExpID" = ?
`

type UpdateExpenseParams struct {
	Description string
	Value       string
	StoreID     int64
	CategoryID  int64
	TypeID      int64
	OwnerUserID int64
	PaidOff     bool
	SharesEven  bool
	ExpDate     int64
	ExpID       int64
}

func (q *Queries) UpdateExpense(ctx context.Context, arg UpdateExpenseParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, updateExpense,
		arg.Description,
		arg.Value,
		arg.StoreID,
		arg.CategoryID,
		arg.TypeID,
		arg.OwnerUserID,
		arg.PaidOff,
		arg.SharesEven,
		arg.ExpDate,
		arg.ExpID,
	)
}

// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: expenses.sql

package repository

import (
	"context"
)

const getExpense = `-- name: GetExpense :one
SELECT 
  expenses.ExpID, expenses.Description, expenses.Value, expenses.StoreID, expenses.CategoryID, expenses.OwnerUserID, expenses.TypeID, expenses.ExpDate, expenses.CreationDate,
  stores.StoreID, stores.StoreName,
  categories.CategoryID, categories.CategoryName,
  users.UserID, users.UserName, users.UserPass,
  types.TypeID, types.TypeName
FROM expenses
JOIN 
  Stores ON stores.StoreID = expenses.StoreID
JOIN 
  Categories ON categories.CategoryID = expenses.CategoryID
JOIN 
  Users ON "UserID" = "OwnerUserId"
JOIN
  "expenseTypes" as types ON types.TypeID = expenses.TypeID
WHERE 
  "ExpID" = ?
`

type GetExpenseRow struct {
	Expense     Expense
	Store       Store
	Category    Category
	User        User
	ExpenseType ExpenseType
}

func (q *Queries) GetExpense(ctx context.Context, expid int64) (GetExpenseRow, error) {
	row := q.db.QueryRowContext(ctx, getExpense, expid)
	var i GetExpenseRow
	err := row.Scan(
		&i.Expense.ExpID,
		&i.Expense.Description,
		&i.Expense.Value,
		&i.Expense.StoreID,
		&i.Expense.CategoryID,
		&i.Expense.OwnerUserID,
		&i.Expense.TypeID,
		&i.Expense.ExpDate,
		&i.Expense.CreationDate,
		&i.Store.StoreID,
		&i.Store.StoreName,
		&i.Category.CategoryID,
		&i.Category.CategoryName,
		&i.User.UserID,
		&i.User.UserName,
		&i.User.UserPass,
		&i.ExpenseType.TypeID,
		&i.ExpenseType.TypeName,
	)
	return i, err
}

const getExpenses = `-- name: GetExpenses :many
SELECT 
  expenses.ExpID, expenses.Description, expenses.Value, expenses.StoreID, expenses.CategoryID, expenses.OwnerUserID, expenses.TypeID, expenses.ExpDate, expenses.CreationDate,
  stores.StoreID, stores.StoreName,
  categories.CategoryID, categories.CategoryName,
  users.UserID, users.UserName, users.UserPass,
  types.TypeID, types.TypeName
FROM expenses
JOIN 
  Stores ON stores.StoreID = expenses.StoreID
JOIN 
  Categories ON categories.CategoryID = expenses.CategoryID
JOIN 
  Users ON UserID = OwnerUserId
JOIN
  "expenseTypes" as types ON types.TypeID = expenses.TypeID
`

type GetExpensesRow struct {
	Expense     Expense
	Store       Store
	Category    Category
	User        User
	ExpenseType ExpenseType
}

func (q *Queries) GetExpenses(ctx context.Context) ([]GetExpensesRow, error) {
	rows, err := q.db.QueryContext(ctx, getExpenses)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetExpensesRow
	for rows.Next() {
		var i GetExpensesRow
		if err := rows.Scan(
			&i.Expense.ExpID,
			&i.Expense.Description,
			&i.Expense.Value,
			&i.Expense.StoreID,
			&i.Expense.CategoryID,
			&i.Expense.OwnerUserID,
			&i.Expense.TypeID,
			&i.Expense.ExpDate,
			&i.Expense.CreationDate,
			&i.Store.StoreID,
			&i.Store.StoreName,
			&i.Category.CategoryID,
			&i.Category.CategoryName,
			&i.User.UserID,
			&i.User.UserName,
			&i.User.UserPass,
			&i.ExpenseType.TypeID,
			&i.ExpenseType.TypeName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

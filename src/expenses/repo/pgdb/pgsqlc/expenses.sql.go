// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: expenses.sql

package pgsqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgconn"
	"github.com/jackc/pgx/v5/pgtype"
)

const deleteExpense = `-- name: DeleteExpense :execresult
WITH delPayments AS (
  DELETE FROM "expensesPayments" WHERE "ExpID" = $1
),
delShares AS (
  DELETE FROM "expensesShares" WHERE "ExpID" = $1
)
DELETE FROM expenses WHERE expenses."ExpID" = $1
`

func (q *Queries) DeleteExpense(ctx context.Context, expid int32) (pgconn.CommandTag, error) {
	return q.db.Exec(ctx, deleteExpense, expid)
}

const getExpense = `-- name: GetExpense :one
SELECT 
  expenses."ExpID", expenses."Description", expenses."Value", expenses."StoreID", expenses."CategoryID", expenses."OwnerUserID", expenses."TypeID", expenses."ExpDate", expenses."CreationDate", expenses."PaidOff", expenses."SharesEven", expenses.qr,
  stores."StoreID", stores."StoreName", stores."NIF",
  categories."CategoryID", categories."CategoryName",
  users."UserID", users."UserName", users."UserPass",
  types."TypeID", types."TypeName"
FROM expenses
JOIN 
  stores ON stores."StoreID" = expenses."StoreID"
JOIN 
  categories ON categories."CategoryID" = expenses."CategoryID"
JOIN 
  users ON "UserID" = "OwnerUserID"
JOIN
  "expenseTypes" as types ON types."TypeID" = expenses."TypeID"
WHERE 
  expenses."ExpID" = $1
`

type GetExpenseRow struct {
	Expense     Expense
	Store       Store
	Category    Category
	User        User
	ExpenseType ExpenseType
}

func (q *Queries) GetExpense(ctx context.Context, expid int32) (GetExpenseRow, error) {
	row := q.db.QueryRow(ctx, getExpense, expid)
	var i GetExpenseRow
	err := row.Scan(
		&i.Expense.ExpID,
		&i.Expense.Description,
		&i.Expense.Value,
		&i.Expense.StoreID,
		&i.Expense.CategoryID,
		&i.Expense.OwnerUserID,
		&i.Expense.TypeID,
		&i.Expense.ExpDate,
		&i.Expense.CreationDate,
		&i.Expense.PaidOff,
		&i.Expense.SharesEven,
		&i.Expense.Qr,
		&i.Store.StoreID,
		&i.Store.StoreName,
		&i.Store.NIF,
		&i.Category.CategoryID,
		&i.Category.CategoryName,
		&i.User.UserID,
		&i.User.UserName,
		&i.User.UserPass,
		&i.ExpenseType.TypeID,
		&i.ExpenseType.TypeName,
	)
	return i, err
}

const getExpenses = `-- name: GetExpenses :many
SELECT 
  expenses."ExpID", expenses."Description", expenses."Value", expenses."StoreID", expenses."CategoryID", expenses."OwnerUserID", expenses."TypeID", expenses."ExpDate", expenses."CreationDate", expenses."PaidOff", expenses."SharesEven", expenses.qr,
  stores."StoreID", stores."StoreName", stores."NIF",
  categories."CategoryID", categories."CategoryName",
  users."UserID", users."UserName", users."UserPass",
  types."TypeID", types."TypeName"
FROM expenses
JOIN 
  stores ON stores."StoreID" = expenses."StoreID"
JOIN 
  categories ON categories."CategoryID" = expenses."CategoryID"
JOIN 
  users ON users."UserID" = expenses."OwnerUserID"
JOIN
  "expenseTypes" as types ON types."TypeID" = expenses."TypeID"
WHERE
  expenses."ExpID" IN (SELECT "ExpID" from "expensesShares" WHERE "expensesShares"."UserID" = $1)
AND
  ($2::timestamp IS NULL OR expenses."ExpDate" >= $2::timestamp)
  AND
  ($3::timestamp IS NULL OR expenses."ExpDate" <= $3::timestamp)
AND
  ($4::int[] IS NULL OR expenses."CategoryID" = ANY($4::int[]))
AND
  ($5::int[] IS NULL OR expenses."StoreID" = ANY($5::int[]))
AND
  ($6::int[] IS NULL OR expenses."TypeID" = ANY($6::int[]))
ORDER BY expenses."ExpDate"
`

type GetExpensesParams struct {
	UserID    int32
	Startdate pgtype.Timestamp
	Enddate   pgtype.Timestamp
	Catids    []int32
	Storeids  []int32
	Typeids   []int32
}

type GetExpensesRow struct {
	Expense     Expense
	Store       Store
	Category    Category
	User        User
	ExpenseType ExpenseType
}

func (q *Queries) GetExpenses(ctx context.Context, arg GetExpensesParams) ([]GetExpensesRow, error) {
	rows, err := q.db.Query(ctx, getExpenses,
		arg.UserID,
		arg.Startdate,
		arg.Enddate,
		arg.Catids,
		arg.Storeids,
		arg.Typeids,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetExpensesRow
	for rows.Next() {
		var i GetExpensesRow
		if err := rows.Scan(
			&i.Expense.ExpID,
			&i.Expense.Description,
			&i.Expense.Value,
			&i.Expense.StoreID,
			&i.Expense.CategoryID,
			&i.Expense.OwnerUserID,
			&i.Expense.TypeID,
			&i.Expense.ExpDate,
			&i.Expense.CreationDate,
			&i.Expense.PaidOff,
			&i.Expense.SharesEven,
			&i.Expense.Qr,
			&i.Store.StoreID,
			&i.Store.StoreName,
			&i.Store.NIF,
			&i.Category.CategoryID,
			&i.Category.CategoryName,
			&i.User.UserID,
			&i.User.UserName,
			&i.User.UserPass,
			&i.ExpenseType.TypeID,
			&i.ExpenseType.TypeName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertExpense = `-- name: InsertExpense :one
INSERT INTO expenses(
  "Description",
  "Value",
  "StoreID",
  "CategoryID",
  "TypeID",
  "OwnerUserID",
  "ExpDate",
  "PaidOff",
  "SharesEven",
  "qr",
  "CreationDate"
)
VALUES($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
RETURNING "ExpID"
`

type InsertExpenseParams struct {
	Description  string
	Value        pgtype.Numeric
	StoreID      int32
	CategoryID   int32
	TypeID       int32
	OwnerUserID  int32
	ExpDate      pgtype.Timestamp
	PaidOff      pgtype.Bool
	SharesEven   pgtype.Bool
	Qr           string
	CreationDate pgtype.Timestamp
}

func (q *Queries) InsertExpense(ctx context.Context, arg InsertExpenseParams) (int32, error) {
	row := q.db.QueryRow(ctx, insertExpense,
		arg.Description,
		arg.Value,
		arg.StoreID,
		arg.CategoryID,
		arg.TypeID,
		arg.OwnerUserID,
		arg.ExpDate,
		arg.PaidOff,
		arg.SharesEven,
		arg.Qr,
		arg.CreationDate,
	)
	var ExpID int32
	err := row.Scan(&ExpID)
	return ExpID, err
}

const updateExpense = `-- name: UpdateExpense :execresult
UPDATE expenses
SET
  "Description" = $1,
  "Value" = $2,
  "StoreID" = $3,
  "CategoryID" = $4,
  "TypeID" = $5,
  "OwnerUserID" = $6,
  "PaidOff" = $7,
  "SharesEven" = $8,
  "qr" = $9,
  "ExpDate" = $10
WHERE "ExpID" = $11
`

type UpdateExpenseParams struct {
	Description string
	Value       pgtype.Numeric
	StoreID     int32
	CategoryID  int32
	TypeID      int32
	OwnerUserID int32
	PaidOff     pgtype.Bool
	SharesEven  pgtype.Bool
	Qr          string
	ExpDate     pgtype.Timestamp
	ExpID       int32
}

func (q *Queries) UpdateExpense(ctx context.Context, arg UpdateExpenseParams) (pgconn.CommandTag, error) {
	return q.db.Exec(ctx, updateExpense,
		arg.Description,
		arg.Value,
		arg.StoreID,
		arg.CategoryID,
		arg.TypeID,
		arg.OwnerUserID,
		arg.PaidOff,
		arg.SharesEven,
		arg.Qr,
		arg.ExpDate,
		arg.ExpID,
	)
}
